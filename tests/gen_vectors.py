#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-only
from __future__ import annotations

import math
import random
from fractions import Fraction
from pathlib import Path

ROOT = Path(__file__).resolve().parent
CORE_OUT = ROOT / "generated_core_vectors.inc"
CPP_OUT = ROOT / "generated_cpp_vectors.inc"


def frac_to_str(v: Fraction) -> str:
    if v.denominator == 1:
        return str(v.numerator)
    return f"{v.numerator}/{v.denominator}"


def canonical(fr: Fraction) -> Fraction:
    if fr.denominator < 0:
        return Fraction(-fr.numerator, -fr.denominator)
    return fr


def parse_frac(s: str) -> Fraction:
    if "/" in s:
        a, b = s.split("/", 1)
        return Fraction(int(a), int(b))
    return Fraction(int(s), 1)


def q(x: str) -> str:
    return '"' + x + '"'


def finite_float_fraction(bits: int) -> tuple[int, Fraction]:
    sign = -1 if (bits >> 31) & 1 else 1
    exp = (bits >> 23) & 0xFF
    frac = bits & 0x7FFFFF
    if exp == 0xFF:
        return (1, Fraction(0, 1))
    if exp == 0:
        if frac == 0:
            return (0, Fraction(0, 1))
        mant = frac
        e2 = 1 - 127 - 23
    else:
        mant = (1 << 23) | frac
        e2 = exp - 127 - 23
    out = Fraction(mant, 1)
    if e2 >= 0:
        out *= (1 << e2)
    else:
        out /= (1 << (-e2))
    if sign < 0:
        out = -out
    return (0, canonical(out))


def finite_double_fraction(bits: int) -> tuple[int, Fraction]:
    sign = -1 if (bits >> 63) & 1 else 1
    exp = (bits >> 52) & 0x7FF
    frac = bits & 0x000FFFFFFFFFFFFF
    if exp == 0x7FF:
        return (1, Fraction(0, 1))
    if exp == 0:
        if frac == 0:
            return (0, Fraction(0, 1))
        mant = frac
        e2 = 1 - 1023 - 52
    else:
        mant = (1 << 52) | frac
        e2 = exp - 1023 - 52
    out = Fraction(mant, 1)
    if e2 >= 0:
        out *= (1 << e2)
    else:
        out /= (1 << (-e2))
    if sign < 0:
        out = -out
    return (0, canonical(out))


def collect_values() -> list[Fraction]:
    vals: list[Fraction] = []
    seen: set[str] = set()

    def push(fr: Fraction) -> None:
        fr2 = canonical(fr)
        s = frac_to_str(fr2)
        if s not in seen:
            seen.add(s)
            vals.append(fr2)

    for i in range(-20, 21):
        push(Fraction(i, 1))

    for p in [0, 1, 2, 3, 7, 15, 31, 40, 52, 63]:
        push(Fraction(1 << p, 1))
        push(Fraction(-(1 << p), 1))

    for x in [
        123456789012345678901234567890,
        -123456789012345678901234567890,
        999999999999999999999999999999999999,
        -999999999999999999999999999999999999,
        18446744073709551615,
        -18446744073709551615,
    ]:
        push(Fraction(x, 1))

    cands: list[Fraction] = []
    for den in range(2, 37):
        for num in range(-den * 6, den * 6 + 1):
            if num == 0:
                continue
            if math.gcd(abs(num), den) != 1:
                continue
            cands.append(Fraction(num, den))
    cands.sort(key=lambda f: (f.denominator, f.numerator))

    for fr in cands:
        if len(vals) >= 96:
            break
        push(fr)

    vals.sort(key=lambda f: (f.denominator, f.numerator))
    return vals


def gen_core(values: list[Fraction]) -> str:
    lines: list[str] = []
    lines.append("/* SPDX-License-Identifier: GPL-3.0-only */")
    lines.append("/* generated by tests/gen_vectors.py; do not edit */")
    lines.append("")

    lines.append("typedef struct limitless_generated_binary_case {")
    lines.append("  const char* a;")
    lines.append("  const char* b;")
    lines.append("  const char* add_s;")
    lines.append("  const char* sub_s;")
    lines.append("  const char* mul_s;")
    lines.append("  const char* div_s;")
    lines.append("  int cmp_ab;")
    lines.append("  int div_status;")
    lines.append("} limitless_generated_binary_case;")
    lines.append("")

    lines.append("static const limitless_generated_binary_case LIMITLESS_GENERATED_BINARY_CASES[] = {")
    for a in values:
        for b in values:
            add_s = frac_to_str(a + b)
            sub_s = frac_to_str(a - b)
            mul_s = frac_to_str(a * b)
            if b == 0:
                div_status = "LIMITLESS_EDIVZERO"
                div_s = "0"
            else:
                div_status = "LIMITLESS_OK"
                div_s = frac_to_str(canonical(a / b))
            cmp_ab = -1 if a < b else (1 if a > b else 0)
            lines.append(
                "  {"
                f"{q(frac_to_str(a))}, {q(frac_to_str(b))}, {q(add_s)}, {q(sub_s)}, {q(mul_s)}, {q(div_s)}, {cmp_ab}, {div_status}"
                "},"
            )
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_BINARY_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_BINARY_CASES) / sizeof(LIMITLESS_GENERATED_BINARY_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_unary_case {")
    lines.append("  const char* value;")
    lines.append("  const char* neg_s;")
    lines.append("  const char* abs_s;")
    lines.append("  int sign;")
    lines.append("  int is_zero;")
    lines.append("  int is_integer;")
    lines.append("  int to_i64_status;")
    lines.append("  int to_u64_status;")
    lines.append("} limitless_generated_unary_case;")
    lines.append("")
    lines.append("static const limitless_generated_unary_case LIMITLESS_GENERATED_UNARY_CASES[] = {")
    min_i64 = -(1 << 63)
    max_i64 = (1 << 63) - 1
    max_u64 = (1 << 64) - 1
    for v in values:
        s = frac_to_str(v)
        neg_s = frac_to_str(-v)
        abs_s = frac_to_str(abs(v))
        sign = -1 if v < 0 else (1 if v > 0 else 0)
        is_zero = 1 if v == 0 else 0
        is_integer = 1 if v.denominator == 1 else 0
        if v.denominator != 1:
            to_i64 = "LIMITLESS_ETYPE"
            to_u64 = "LIMITLESS_ETYPE"
        else:
            n = v.numerator
            to_i64 = "LIMITLESS_OK" if (min_i64 <= n <= max_i64) else "LIMITLESS_ERANGE"
            to_u64 = "LIMITLESS_OK" if (0 <= n <= max_u64) else "LIMITLESS_ERANGE"
        lines.append(
            "  {"
            f"{q(s)}, {q(neg_s)}, {q(abs_s)}, {sign}, {is_zero}, {is_integer}, {to_i64}, {to_u64}"
            "},"
        )
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_UNARY_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_UNARY_CASES) / sizeof(LIMITLESS_GENERATED_UNARY_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_base_case {")
    lines.append("  const char* value;")
    lines.append("  int base;")
    lines.append("} limitless_generated_base_case;")
    lines.append("")
    lines.append("static const limitless_generated_base_case LIMITLESS_GENERATED_BASE_CASES[] = {")
    base_values = values[:48]
    for v in base_values:
        for base in [2, 8, 10, 16, 36]:
            lines.append(f"  {{{q(frac_to_str(v))}, {base}}},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_BASE_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_BASE_CASES) / sizeof(LIMITLESS_GENERATED_BASE_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_float_case {")
    lines.append("  limitless_u32 bits;")
    lines.append("  int status;")
    lines.append("  const char* expected;")
    lines.append("} limitless_generated_float_case;")
    lines.append("")
    lines.append("typedef struct limitless_generated_double_case {")
    lines.append("  limitless_u64 bits;")
    lines.append("  int status;")
    lines.append("  const char* expected;")
    lines.append("} limitless_generated_double_case;")
    lines.append("")

    rng = random.Random(424242)
    float_bits = [
        0x00000000,
        0x80000000,
        0x3f000000,
        0x3f800000,
        0x40133333,
        0x7f7fffff,
        0x00800000,
        0x00000001,
        0x7f800000,
        0xff800000,
        0x7fc00000,
    ]
    while len(float_bits) < 128:
        float_bits.append(rng.getrandbits(32))
    # keep deterministic order while removing dupes
    seen_bits: set[int] = set()
    uniq_float: list[int] = []
    for b in float_bits:
        if b not in seen_bits:
            seen_bits.add(b)
            uniq_float.append(b)
    lines.append("static const limitless_generated_float_case LIMITLESS_GENERATED_FLOAT_CASES[] = {")
    for b in uniq_float:
        st, fr = finite_float_fraction(b)
        if st != 0:
            lines.append(f"  {{0x{b:08x}u, LIMITLESS_EINVAL, \"\"}},")
        else:
            lines.append(f"  {{0x{b:08x}u, LIMITLESS_OK, {q(frac_to_str(fr))}}},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_FLOAT_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_FLOAT_CASES) / sizeof(LIMITLESS_GENERATED_FLOAT_CASES[0]));")
    lines.append("")

    rng = random.Random(212121)
    double_bits = [
        0x0000000000000000,
        0x8000000000000000,
        0x3fe0000000000000,
        0x3ff0000000000000,
        0x4002666666666666,
        0x7fefffffffffffff,
        0x0010000000000000,
        0x0000000000000001,
        0x7ff0000000000000,
        0xfff0000000000000,
        0x7ff8000000000000,
    ]
    while len(double_bits) < 128:
        double_bits.append(rng.getrandbits(64))
    seen_bits64: set[int] = set()
    uniq_double: list[int] = []
    for b in double_bits:
        if b not in seen_bits64:
            seen_bits64.add(b)
            uniq_double.append(b)
    lines.append("static const limitless_generated_double_case LIMITLESS_GENERATED_DOUBLE_CASES[] = {")
    for b in uniq_double:
        st, fr = finite_double_fraction(b)
        if st != 0:
            lines.append(f"  {{0x{b:016x}ULL, LIMITLESS_EINVAL, \"\"}},")
        else:
            lines.append(f"  {{0x{b:016x}ULL, LIMITLESS_OK, {q(frac_to_str(fr))}}},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_DOUBLE_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_DOUBLE_CASES) / sizeof(LIMITLESS_GENERATED_DOUBLE_CASES[0]));")
    lines.append("")

    ints = [v for v in values if v.denominator == 1]
    ints.sort(key=lambda x: (abs(x.numerator), x.numerator))
    ints = ints[:56]

    lines.append("typedef struct limitless_generated_gcd_case {")
    lines.append("  const char* a;")
    lines.append("  const char* b;")
    lines.append("  const char* g;")
    lines.append("} limitless_generated_gcd_case;")
    lines.append("")
    lines.append("static const limitless_generated_gcd_case LIMITLESS_GENERATED_GCD_CASES[] = {")
    for a in ints:
        for b in ints:
            g = math.gcd(abs(a.numerator), abs(b.numerator))
            lines.append(f"  {{{q(frac_to_str(a))}, {q(frac_to_str(b))}, {q(str(g))}}},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_GCD_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_GCD_CASES) / sizeof(LIMITLESS_GENERATED_GCD_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_pow_case {")
    lines.append("  const char* base;")
    lines.append("  limitless_u64 exp;")
    lines.append("  const char* out;")
    lines.append("} limitless_generated_pow_case;")
    lines.append("")
    lines.append("static const limitless_generated_pow_case LIMITLESS_GENERATED_POW_CASES[] = {")
    for a in ints[:36]:
        for e in [0, 1, 2, 3, 5, 8]:
            out = Fraction(a.numerator ** e, 1)
            lines.append(f"  {{{q(frac_to_str(a))}, {e}ULL, {q(frac_to_str(out))}}},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_POW_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_POW_CASES) / sizeof(LIMITLESS_GENERATED_POW_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_modexp_case {")
    lines.append("  const char* base;")
    lines.append("  limitless_u64 exp;")
    lines.append("  const char* mod;")
    lines.append("  int status;")
    lines.append("  const char* out;")
    lines.append("} limitless_generated_modexp_case;")
    lines.append("")
    lines.append("static const limitless_generated_modexp_case LIMITLESS_GENERATED_MODEXP_CASES[] = {")
    mods = [Fraction(x, 1) for x in [-7, -1, 0, 1, 2, 3, 5, 97]]
    for a in ints[:30]:
        for e in [0, 1, 2, 5, 13]:
            for m in mods:
                if m.numerator <= 0:
                    lines.append(f"  {{{q(frac_to_str(a))}, {e}ULL, {q(frac_to_str(m))}, LIMITLESS_EDIVZERO, \"\"}},")
                else:
                    out = pow(a.numerator % m.numerator, e, m.numerator)
                    lines.append(f"  {{{q(frac_to_str(a))}, {e}ULL, {q(frac_to_str(m))}, LIMITLESS_OK, {q(str(out))}}},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_MODEXP_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_MODEXP_CASES) / sizeof(LIMITLESS_GENERATED_MODEXP_CASES[0]));")
    lines.append("")

    return "\n".join(lines) + "\n"


def gen_cpp(values: list[Fraction]) -> str:
    lines: list[str] = []
    lines.append("/* SPDX-License-Identifier: GPL-3.0-only */")
    lines.append("/* generated by tests/gen_vectors.py; do not edit */")
    lines.append("")

    lines.append("typedef struct limitless_generated_cpp_int_left_case {")
    lines.append("  long long lhs;")
    lines.append("  const char* rhs;")
    lines.append("  const char* add_s;")
    lines.append("  const char* sub_s;")
    lines.append("  const char* mul_s;")
    lines.append("  const char* div_s;")
    lines.append("  int div_status;")
    lines.append("  int cmp;")
    lines.append("} limitless_generated_cpp_int_left_case;")
    lines.append("")

    rhs_vals = values[:40]
    lhs_vals = [-100, -7, -1, 0, 1, 2, 3, 10, 100, 123456789]
    lines.append("static const limitless_generated_cpp_int_left_case LIMITLESS_GENERATED_CPP_INT_LEFT_CASES[] = {")
    for lhs in lhs_vals:
        lf = Fraction(lhs, 1)
        for rhs in rhs_vals:
            add_s = frac_to_str(lf + rhs)
            sub_s = frac_to_str(lf - rhs)
            mul_s = frac_to_str(lf * rhs)
            if rhs == 0:
                div_status = "LIMITLESS_EDIVZERO"
                div_s = ""
            else:
                div_status = "LIMITLESS_OK"
                div_s = frac_to_str(canonical(lf / rhs))
            cmp = -1 if lf < rhs else (1 if lf > rhs else 0)
            lines.append(
                "  {"
                f"{lhs}LL, {q(frac_to_str(rhs))}, {q(add_s)}, {q(sub_s)}, {q(mul_s)}, {q(div_s)}, {div_status}, {cmp}"
                "},"
            )
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_CPP_INT_LEFT_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_CPP_INT_LEFT_CASES) / sizeof(LIMITLESS_GENERATED_CPP_INT_LEFT_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_cpp_double_left_case {")
    lines.append("  double lhs;")
    lines.append("  const char* lhs_exact;")
    lines.append("  const char* rhs;")
    lines.append("  const char* add_s;")
    lines.append("  const char* sub_s;")
    lines.append("  const char* mul_s;")
    lines.append("  const char* div_s;")
    lines.append("  int div_status;")
    lines.append("  int cmp;")
    lines.append("} limitless_generated_cpp_double_left_case;")
    lines.append("")

    double_vals = [0.5, -2.25, 3.5, 2.3, -0.125, 10.0]
    rhs_vals2 = values[:24]
    lines.append("static const limitless_generated_cpp_double_left_case LIMITLESS_GENERATED_CPP_DOUBLE_LEFT_CASES[] = {")
    for lhs in double_vals:
        # exact rational value from binary64 representation
        lf = Fraction(*lhs.as_integer_ratio())
        lhs_exact = frac_to_str(canonical(lf))
        for rhs in rhs_vals2:
            add_s = frac_to_str(lf + rhs)
            sub_s = frac_to_str(lf - rhs)
            mul_s = frac_to_str(lf * rhs)
            if rhs == 0:
                div_status = "LIMITLESS_EDIVZERO"
                div_s = ""
            else:
                div_status = "LIMITLESS_OK"
                div_s = frac_to_str(canonical(lf / rhs))
            cmp = -1 if lf < rhs else (1 if lf > rhs else 0)
            lines.append(
                "  {"
                f"{lhs:.17g}, {q(lhs_exact)}, {q(frac_to_str(rhs))}, {q(add_s)}, {q(sub_s)}, {q(mul_s)}, {q(div_s)}, {div_status}, {cmp}"
                "},"
            )
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_CPP_DOUBLE_LEFT_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_CPP_DOUBLE_LEFT_CASES) / sizeof(LIMITLESS_GENERATED_CPP_DOUBLE_LEFT_CASES[0]));")
    lines.append("")

    lines.append("typedef struct limitless_generated_cpp_parse_case {")
    lines.append("  const char* value;")
    lines.append("  int base;")
    lines.append("  const char* expected;")
    lines.append("} limitless_generated_cpp_parse_case;")
    lines.append("")
    lines.append("static const limitless_generated_cpp_parse_case LIMITLESS_GENERATED_CPP_PARSE_CASES[] = {")
    for v in values[:64]:
        lines.append(f"  {{{q(frac_to_str(v))}, 10, {q(frac_to_str(v))}}},")
    # add base-autodetect literals
    lines.append("  {\"0xff\", 0, \"255\"},")
    lines.append("  {\"0b101101\", 0, \"45\"},")
    lines.append("  {\"-0x20\", 0, \"-32\"},")
    lines.append("};")
    lines.append("static const limitless_size LIMITLESS_GENERATED_CPP_PARSE_CASE_COUNT = (limitless_size)(sizeof(LIMITLESS_GENERATED_CPP_PARSE_CASES) / sizeof(LIMITLESS_GENERATED_CPP_PARSE_CASES[0]));")
    lines.append("")

    return "\n".join(lines) + "\n"


def main() -> None:
    values = collect_values()
    core_text = gen_core(values)
    cpp_text = gen_cpp(values)
    CORE_OUT.write_text(core_text, encoding="utf-8")
    CPP_OUT.write_text(cpp_text, encoding="utf-8")
    print(f"wrote {CORE_OUT}")
    print(f"wrote {CPP_OUT}")
    print(f"values={len(values)}")


if __name__ == "__main__":
    main()
